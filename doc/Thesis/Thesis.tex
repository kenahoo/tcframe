\documentclass[a4paper]{report}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{amsfonts}

\title{Thesis}
\author{Ken Williams}
\begin{document}

\maketitle

\chapter*{Abstract}
\chapter*{Acknowledgements}

\tableofcontents

\chapter{Introduction}

\section{Preface}

The field of Automatic Text Categorization is an extremely active area
of current research and application.  It is a multi-disciplinary
field, attracting attention from the Linguistics, Computer Science,
Engineering, and Business communities.  Its applicability is broad,
with many potential uses for large businesses as well as individuals.

The goal of Automatic Text Categorization is to produce specialized
algorithms that can process natural-language documents, assigning zero
or more user-defined labels to them based on their content.  More
formally, given a set of labels $L = \{L_1, \ldots, L_k\}$ and a set of
previously unseen documents $D = \{D_1, D_2, \ldots \}$, a categorizer is a
function $C$ that maps from $D$ to the set of all subsets of $L$.  In
practice, many categorizers assign only a single label to each
document, so a categorizer is often a function that maps directly from
$D$ to $L$.  Often an intermediate function is useful for "soft" or 
"rank-based" categorization, mapping from ordered pairs $(D_i, C_j)$ 
to the set of real numbers $\mathbb{R}$ in order to assign a score 
to each category $C_j$ for each document $D_i$.

The standard modern approach to creating new categorizer functions is
to build them using Machine Learning techniques from a set of training
documents.  This is a set of user-provided, pre-labeled documents that
follows a category
distribution similar to the distribution of $D$, and whose contents
provide information about what sorts of documents should be mapped to
what sorts of categories.  Algorithms can then be developed that make
generalizations about the relationship between document content and
document category, encoding these generalizations in the algorithm $C$.

\section{Automatic Text Categorization}

\section{Object Frameworks}

A framework is a large-scale unit of reusable code in object-oriented
software development.  Frameworks were developed in response to
situations requiring fine-grained control over the

\subsection{Guidelines for designing frameworks}
\subsection{Design patterns}


\section{Overview of AI::Categorizer Framework}

AI::Categorizer is a set of Perl modules that implements an
object-oriented framework for text categorization.  It provides
classes for managing documents, categories, machine learners,
categorization hypotheses, and categorization results.

\section{Contributions}

\section{Organization of the Thesis}

\chapter{Practical Issues in Text Categorization}

\section{Usage Scenarios (use cases)}
\subsection{Commercial scenarios}
\subsection{Research scenarios}

\section{General Text Categorization Considerations}
\subsection{Document format}
\subsection{Document structure}
\subsection{Tokenizing of data}
\subsection{Linguistic stemming}
\subsection{Feature selection}
\subsection{Vector space modeling}
\subsection{Machine learning algorithm choice}
\subsection{Machine learning configuration}
\subsection{Incremental or on-line learning}
\subsection{Hypothesis behavior}

\section{Machine learning techniques}
\subsection{Naive Bayes}
\subsection{Decision Trees}
\subsection{Support Vector Machines}

\section{Application integration}
\subsection{Client/server applications}
\subsection{Embedded applications}
\subsection{Database cooperation}

\section{Evaluation}
\subsection{Correctness}
Precision, recall, FN2, error, accuracy
\subsection{Usefulness}
ROC curves
\subsection{Scalability}
\subsubsection{Architecture}
\subsubsection{Running time}
\subsubsection{Memory usage}

\section{Related products}

To establish the relevance of AI::Categorizer in the marketplace of
Text Categorization, I will examine three related products.  First I
discuss Weka, a Java product that has been used successfully by many
Text Categorization researchers.  Then I address two businesses that
supply products and services related to Text Categorization,
Autonomy.com and Teragram Corporation.

\subsection{Weka}

Weka is an open-source system for Machine Learning originally
developed at the XXX University of Waikato, New Zealand.  Its primary
audience is the international community of academic machine learning
researchers, most notably those working with Categorization or
Clustering problems that arise from working with text.  Weka has
undergone at least one major code rewrite; at present it is
implemented as a set of related Java classes with documented internal
interfaces, so it may itself be considered a framework.

Weka is used extensively throughout the academic Text Categorization
community, and as such includes support for many cutting-edge
categorization techniques, including advances in Support Vector
Machines, k-Nearest-Neighbor, Naive Bayes, and other categorizers, as
well as several variations of feature selection techniques.  It is
therefore a standard against which the AI::Categorizer framework can
be measured, as well as a resource which can be leveraged in its
construction.

Despite some similar properties, Weka and AI::Categorizer differ in
their goals and in many important implementation decisions.  Whereas
Weka specifically targets the academic research community,
AI::Categorizer aims to support use cases under both
application-building and research-conducting situations.
Consequently, Weka will typically keep up with research trends more
closely, but AI::Categorizer will usually be easier for application
developers to integrate into a real-world situation.

In addition to these differences, another important difference arises
from the different goals in the two projects.  Much of the academic
community is interested in evaluating the correctness and algorithmic
complexity of categorization techniques, whereas most application
developers must also consider resource usage in real-world terms like
time and memory.  In testing, AI::Categorizer has greatly outperformed
Weka in terms of speed and memory when equivalent algorithms are
compared on identical data sets.  This doesn't reflect an inherent
design flaw in Weka, rather a difference in the kinds of things Weka
developers are likely to spend their time working on.

In order to help facilitate cooperation between the Weka and
AI::Categorizer communities, as well as leverage existing solutions
inside AI::Categorizer, a machine learner class has been created
within AI::Categorizer that simply passes data through to Weka's
categorizers.  In this way, application developers can easily
experiment with Weka's cutting-edge categorization techniques while
retaining AI::Categorizer's application integration advantages.  Any
cross-pollination generated as a result will likely benefit both
projects.

Other facilities provided by Weka are not yet offered by
AI::Categorizer.  These include visualization tools, several
sophisticated correctness evaluation tools, and XXX.  Most of these
facilities would make useful additions to AI::Categorizer if
implemented

\subsection{Autonomy.com}

\subsection{Teragram Corporation}

According to their web site (http://www.teragram.com/), Teragram
Corporation is a provider of ``fast and stable linguistic
technologies, information search and extraction, knowledge management,
and text processing technologies.''  One of their largest-scale
products is the Teragram Categorizer, an automatic document
categorizer that plays a similar technical role to AI::Categorizer.
It cooperates with the Teragram Taxonomy Manager, which provides a
user interface to categories and the documents within each category.

All of Teragram's software products are proprietary, so little
information on implementation is available.  However, product
capabilities and roles can be assessed from the marketing information
given on the web site.  The information presented here has all been
gathered this way.

The Taxonomy Manager is a browser of hierarchical categories, similar
to several on-line directory services like Yahoo
(http://www.yahoo.com/) or the Open Directory Project
(http://www.dmoz.org/).  It might therefore be inferred that the
Categorizer is a native hierarchical categorizer, or perhaps that the
categorizer actually flattens the tree structure of the category
hierarchy into a flat list of its leaves, and imposes the tree
structure only afterwards.  Whichever case is true, it must be noted
that the interfaces of the categorizer allow hierarchical
categorization even if the internal workings are flat.

Another interesting aspect of Teragram's categorization technology is
their Rule-Based Categorizer.  Using this system, ``each category
within the directory is associated with a set of rules that describe
documents within that category.''  This may be motivated by a need to
integrate older hand-maintained lists of rules into newer
applications, or it might be meant to address situations like email
categorization in which most documents are indeed best categorized by
simple rules (usually because the sender and receiver have agreed upon
a tagging scheme to mark documents' important properties).  It's not
clear whether Teragram's Rule-Based Categorizer and Automatic
Categorizer can cooperate on a single taxonomy, but they indicate that
the two systems are complementary rather than antithetic.

Teragram also offers separate licensing for many of the tools that
make up its products.  In this sense, it has a strategy similar to one
employed in AI::Categorizer's design, in which useful pieces of
functionality created for AI::Categorizer should be split off into
their own products whenever possible.

\section{Dissemination}
\subsection{Documentation}
\subsection{Community involvement}

\chapter{AI::Categorizer Framework Design}

The AI::Categorizer framework is designed for maximum re-use in many
kinds of situations \ldots XXX.

For brevity, we will omit the ``AI::Categorizer::'' prefix from class
names in this discussion.  It is to be understood that any class
within the AI::Categorizer framework (except the top-level class
AI::Categorizer itself) is prefixed by the ``AI::Categorizer::''
namespace.

\section{Overview of AI::Categorizer class hierarchy}

In order to understand the structure of the AI::Categorizer framework,
multiple kinds of analysis are helpful.  We can examine the
inheritance relationships of the classes that participate in
AI::Categorizer, and indicate which classes inherit from each other.
Since a class generally is a representation of certain
responsibilities and capabilities, this lets us see how the set of
responsibilities for one class may be implemented in different ways or
extended by its subclasses.

\begin{figure}
\includegraphics[width=\linewidth]{figures/inheritance-uml.pdf}
\caption{Inheritance diagram for AI::Categorizer}
\label{inheritance-uml}
\end{figure}

Figure \ref{inheritance-uml} shows the inheritance relationships among
classes in the AI::Categorizer framework.  Note that this diagram
indicates the \emph{capabilities} of the framework more than it
indicates its \emph{architecture}.  For instance, the framework
currently understands several document types, including plain text
documents and documents in the ``SMART'' format.  If the framework is
extended by writing additional subclasses of existing classes, the
capabilities increase without changing the basic architecture of the
framework.

Note that the inheritance diagram is not particularly enlightening
about how various classes cooperate to perform text categorization
tasks.  The inheritance relationships are set at compile-time and do
not change while the framework is in use.\footnote{Perl allows the
dynamic reassignment of inheritance, but this capability isn't used
in the framework.}

Another way to examine the framework is to examine the run-time
relationships between its classes.  This often provides a much more
enlightening analysis of a framework, since modern framework design
often favors object composition over class inheritance for its
important structural elements. \cite[p. 20]{gamma:95}

The class composition diagram in figure \ref{classes-uml} shows the
most important run-time relationships between classes in the
AI::Categorizer framework.  In this diagram, no inheritance
relationships are shown--any inheritance hierarchies are represented
only by their parent classes.  In general, a class and its subclass
will share an interface and have identical relationships to other
classes, but will differ in implementation.  Therefore, the
relationships indicated in this diagram indicate stable aspects of the
framework that do not change when the framework is extended by
subclassing.

Some examination of the basic relationships between classes and the
responsibilities of each class is helpful before looking at the design
in more detail.

\subsection{KnowledgeSet}

The KnowledgeSet class represents a set of processed documents, a set
of categories, and a many-to-many mapping between the two sets.
Processing may involve tokenization, stopword removal, linguistic
stemming, feature selection, and vector weighting.  Note that the term
``knowledge set'' is somewhat unique to this project.

A KnowledgeSet contains references to many Document objects and
Category objects.  It uses Collection objects to instantiate Document
and Category objects.  It uses a FeatureSelector object to perform
feature selection.  It also contains a FeatureVector object
representing the features present in all documents.

\subsection{FeatureSelector}

Feature selection is performed by subclasses of the FeatureSelector
class.  Each KnowledgeSet object contains a FeatureSelector
object--the KnowledgeSet provides the information necessary to do
feature selection, and the FeatureSelector performs the desired
feature selection algorithm.

\subsection{Collection}

Because data sets in text categorization may be very large, and
because their documents may exist in several different underlying
storage mechanisms (e.g. as files in a filesystem, sections of a
larger XML file, or fields in a database), a Collection class provides
an abstract interface to a set of stored documents, together with a
way to iterate through the set and return Document objects.

A Collection object may be used in several contexts within the
framework.  For instance, a KnowledgeSet instantiates its Document and
Category objects through a Collection object.  A Learner object may
also mass-categorize the Documents in a Collection object.

\subsection{Document}

Each text document is represented by a Document object, or an object
of one of its subclasses.  Each document class contains methods for
turning a bunch of data into a Feature Vector.  Each document also has
a method to report which categories it belongs to.

=head2 Categories

Each category is represented by an C<AI::Categorizer::Category>
object.  Its main purpose is to keep track of which documents belong
to it, though you can also examine statistical properties of an entire
category, such as obtaining a Feature Vector representing an
amalgamation of all the documents that belong to it.

=head2 Machine Learning Algorithms

There are lots of different ways to make the inductive leap from the
training documents to unseen documents.  The Machine Learning
community has studied many algorithms for this purpose.  To allow
flexibility in choosing and configuring categorization algorithms,
each such algorithm is a subclass of C<AI::Categorizer::Learner>.
There are currently four categorizers included in the distribution:

=over 4

=item AI::Categorizer::Learner::NaiveBayes

A pure-perl implementation of a Naive Bayes classifier.  No
dependencies on external modules or other resources.  Naive Bayes is
usually very fast to train and fast to make categorization decisions,
but isn't always the most accurate categorizer.

=item AI::Categorizer::Learner::SVM

An interface to Corey Spencer's C<Algorithm::SVM>, which implements a
Support Vector Machine classifier.  SVMs can take a while to train
(though in certain conditions there are optimizations to make them
quite fast), but are pretty quick to categorize.  They often have very
good accuracy.

=item AI::Categorizer::Learner::DecisionTree

An interface to C<AI::DecisionTree>, which implements a Decision Tree
classifier.  Decision Trees generally take longer to train than Naive
Bayes or SVM classifiers, but they are also quite fast when
categorizing.  Decision Trees have the advantage that you can
scrutinize the structures of trained decision trees to see how
decisions are being made.

=item AI::Categorizer::Learner::Weka

An interface to version 2 of the Weka Knowledge Analysis system that
lets you use any of the machine learners it defines.  This gives you
access to lots and lots of machine learning algorithms in use by
machine learning researches.  The main drawback is that Weka tends to
be quite slow and use a lot of memory, and the current interface
between Weka and C<AI::Categorizer> is a bit clumsy.

=back

Other machine learning methods that may be implemented soonish include
Neural Networks, k-Nearest-Neighbor, and/or a mixture-of-experts
combiner for ensemble learning.  No timetable for their creation has
yet been set.

Please see the documentation of these individual modules for more
details on their guts and quirks.  See the C<AI::Categorizer::Learner>
documentation for a description of the general categorizer interface.
If you wish to create your own classifier, you should inherit from
C<AI::Categorizer::Learner> or C<AI::Categorizer::Learner::Boolean>,
which are abstract classes that manage some of the work for you.

=head2 Feature Vectors

Most categorization algorithms don't deal directly with documents'
data, they instead deal with a I<vector representation> of a
document's I<features>.  The features may be any properties of the
document that seem helpful for determining its category, but they are
usually
some version of the ``most important'' words in the document.  A list
of
features and their weights in each document is encapsulated by the
C<AI::Categorizer::FeatureVector> class.  You may think of this class
as roughly analogous to a Perl hash, where the keys are the names of
features and the values are their weights.

=head2 Hypotheses

The result of asking a categorizer to categorize a previously unseen
document is called a hypothesis, because it is some kind of
``statistical guess'' of what categories this document should be
assigned to.  Since you may be interested in any of several pieces of
information about the hypothesis (for instance, which categories were
assigned, which category was the single most likely category, the
scores assigned to each category, etc.), the hypothesis is returned as
an object of the C<AI::Categorizer::Hypothesis> class, and you can use
its object methods to get information about the hypothesis.  See its
class documentation for the details.

=head2 Experiments

The C<AI::Categorizer::Experiment> class helps you organize the
results of categorization experiments.  As you get lots of
categorization results (Hypotheses) back from the Learner, you can
feed these results to the Experiment class, along with the correct
answers.  When all results have been collected, you can get a report
on accuracy, precision, recall, F1, and so on, with both
micro-averaging and macro-averaging over categories.  We use the
C<Statistics::Contingency> module from CPAN to manage the
calculations. See the docs for C<AI::Categorizer::Experiment> for more
details.



\begin{figure}
\includegraphics[width=\linewidth]{figures/classes-uml.pdf}
\caption{Class composition diagram for AI::Categorizer}
\label{classes-uml}
\end{figure}

\section{Design Patterns in AI::Categorizer}

\subsection{Iterator}
\begin{figure}
\includegraphics[width=\linewidth]{figures/Iterator.pdf}
\caption{The Iterator pattern in the Collection class}
\label{Iterator-collection}
\end{figure}

\subsection{Composite}
\begin{figure}
\includegraphics[width=\linewidth]{figures/Composite.pdf}
\caption{The Composite pattern in the Learner::Ensemble class}
\label{Composite-ensemble}
\end{figure}

\subsection{Adapter}
\begin{figure}
\includegraphics[width=\linewidth]{figures/Adapter.pdf}
\caption{The Adapter pattern in the Learner class}
\label{Adapter-learner}
\end{figure}

\subsection{Strategy}
\begin{figure}
\includegraphics[width=\linewidth]{figures/Strategy.pdf}
\caption{The Strategy pattern in the Learner class}
\label{Strategy-learner}
\end{figure}

\begin{figure}
\includegraphics[width=\linewidth]{figures/Strategy-feasel.pdf}
\caption{The Strategy pattern in the FeatureSelector class}
\label{Strategy-feasel}
\end{figure}

\subsection{Factory Method}

\chapter{Implementation}

\section{Language}
\section{Data Structures}

\chapter{Evaluation}

\section{Descriptions of corpora}
During development and testing, several data sets are used for
framework testing and application building.  The main data sets are
listed here.


\subsection{ApteMod (Reuters-21578)}


The "ApteMod" version of the Reuters-21578 corpus has become a
standard benchmark corpus in evaluating Text Categorization systems.
It is a collection of 10,788 documents from the Reuters newswire
service, partitioned into a training set with 7769 documents and a
test set with 3019 documents.  The total size of the corpus is about
17.5 Mb.  It is available from
http://moscow.mt.cs.cmu.edu:8081/reuters\_21578/ in SMART format.


\subsection{SignalG}
This corpus consists of 122,919 financial announcement documents from
the Australian Stock Exchange between January 4 and December 29, 2000.
The documents are hand- categorized according to whether they indicate
"market sensitivity" or not.  Every document is a member of either the
"sensitive" or "insensitive" category--we can view this as two
categories that partition the corpus, or as a single category
"sensitive" that some documents belong to and others don't.  The
documents are split into a training set of 81,814 documents and a test
set of 41,105 documents.


\subsection{DrMath}
This is a smallish collection (26.5 Mb) of English-language messages
sent to the "Ask Dr. Math" question-and-answer service for students
(http://www.mathforum.org/dr.math/).  It consists of messages
containing math questions, categorized by topic and grade level.  Each
category specifies both topic and grade level information (i.e. "High
School Geometry"), so these categorization tasks are not generally
separable into a categorization by topic and a categorization by
level.  The corpus is divided into a training set with 5304 documents
and a test set with 1326 documents.  The corpus is not available for
direct download, but you may contact Ken Williams for details.


\subsection{Reuters-CRC}
This is a collection of financial announcements gathered from the
Reuters financial service in the year 2000.  It represents all
announcements sent by the top 500 companies on the Australian Stock
Exchange (determined by trading volume) during 2000.  There are 27,874
documents, partitioned randomly into 18,568 training documents and
9,306 test documents (105 Mb training, 52.5 Mb test).  We have imposed
a categorization scheme on the data set by examining trends in related
training data, so that each document becomes a member of either the
category "insensitive" or "sensitive", similar to the SignalG data
set.  The corpus is the property of Capital Markets Cooperative
Research Centre and is not available for use by outside groups.


\section{Performance evaluation}

\section{Applications}

\chapter{Conclusion}

\bibliographystyle{plain}
\bibliography{TC-references}

\end{document}
